// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="2")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, repeated, tag="3")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(uint64, tag="1")]
    pub number: u64,
    #[prost(bytes="vec", tag="2")]
    pub tx_trie_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub witness_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="4")]
    pub parent_number: u64,
    #[prost(bytes="vec", tag="5")]
    pub parent_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag="6")]
    pub version: u32,
    #[prost(int64, tag="7")]
    pub timestamp: i64,
    #[prost(bytes="vec", tag="8")]
    pub witness_signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(bytes="vec", tag="1")]
    pub txid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", repeated, tag="2")]
    pub signature: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", tag="3")]
    pub ref_block_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub ref_block_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag="5")]
    pub expiration: i64,
    #[prost(int64, tag="6")]
    pub timestamp: i64,
    #[prost(bytes="vec", repeated, tag="7")]
    pub contract_result: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, tag="8")]
    pub result: bool,
    #[prost(enumeration="ResponseCode", tag="9")]
    pub code: i32,
    #[prost(bytes="vec", tag="10")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag="11")]
    pub energy_used: i64,
    #[prost(int64, tag="12")]
    pub energy_penalty: i64,
    #[prost(message, optional, tag="13")]
    pub info: ::core::option::Option<super::super::super::super::protocol::TransactionInfo>,
    #[prost(message, repeated, tag="14")]
    pub contracts: ::prost::alloc::vec::Vec<super::super::super::super::protocol::transaction::Contract>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResponseCode {
    Success = 0,
    Sigerror = 1,
    ContractValidateError = 2,
    ContractExeError = 3,
    BandwithError = 4,
    DupTransactionError = 5,
    TaposError = 6,
    TooBigTransactionError = 7,
    TransactionExpirationError = 8,
    ServerBusy = 9,
    NoConnection = 10,
    NotEnoughEffectiveConnection = 11,
    BlockUnsolidified = 12,
    OtherError = 20,
}
impl ResponseCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResponseCode::Success => "SUCCESS",
            ResponseCode::Sigerror => "SIGERROR",
            ResponseCode::ContractValidateError => "CONTRACT_VALIDATE_ERROR",
            ResponseCode::ContractExeError => "CONTRACT_EXE_ERROR",
            ResponseCode::BandwithError => "BANDWITH_ERROR",
            ResponseCode::DupTransactionError => "DUP_TRANSACTION_ERROR",
            ResponseCode::TaposError => "TAPOS_ERROR",
            ResponseCode::TooBigTransactionError => "TOO_BIG_TRANSACTION_ERROR",
            ResponseCode::TransactionExpirationError => "TRANSACTION_EXPIRATION_ERROR",
            ResponseCode::ServerBusy => "SERVER_BUSY",
            ResponseCode::NoConnection => "NO_CONNECTION",
            ResponseCode::NotEnoughEffectiveConnection => "NOT_ENOUGH_EFFECTIVE_CONNECTION",
            ResponseCode::BlockUnsolidified => "BLOCK_UNSOLIDIFIED",
            ResponseCode::OtherError => "OTHER_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUCCESS" => Some(Self::Success),
            "SIGERROR" => Some(Self::Sigerror),
            "CONTRACT_VALIDATE_ERROR" => Some(Self::ContractValidateError),
            "CONTRACT_EXE_ERROR" => Some(Self::ContractExeError),
            "BANDWITH_ERROR" => Some(Self::BandwithError),
            "DUP_TRANSACTION_ERROR" => Some(Self::DupTransactionError),
            "TAPOS_ERROR" => Some(Self::TaposError),
            "TOO_BIG_TRANSACTION_ERROR" => Some(Self::TooBigTransactionError),
            "TRANSACTION_EXPIRATION_ERROR" => Some(Self::TransactionExpirationError),
            "SERVER_BUSY" => Some(Self::ServerBusy),
            "NO_CONNECTION" => Some(Self::NoConnection),
            "NOT_ENOUGH_EFFECTIVE_CONNECTION" => Some(Self::NotEnoughEffectiveConnection),
            "BLOCK_UNSOLIDIFIED" => Some(Self::BlockUnsolidified),
            "OTHER_ERROR" => Some(Self::OtherError),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
